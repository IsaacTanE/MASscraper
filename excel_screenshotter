# -*- coding: utf-8 -*-
# Requirements: pip install pywin32
# Windows + desktop Outlook/Excel

import tempfile
from pathlib import Path
from contextlib import contextmanager
from datetime import datetime, timedelta

import pythoncom
import win32com.client as win32

# ====== CONFIGURE ======
EXCEL_PATH = r"C:\path\to\your\workbook.xlsx"   # <- change me
SHEET_NAME = None                                # e.g. "Sheet1"; None = ActiveSheet
RANGE_ADDR = "A1:E40"

YIELD_SHEET = "Yield"
YIELD_CELL = "L3"

TARGET_SENDER_SMTP = "isaactane@dbs.com"         # since it's in Sent Items
HOLIDAYS = set()                                 # e.g. {"2025-01-01","2025-08-09"}
# =======================

@contextmanager
def com_apartment():
    pythoncom.CoInitialize()
    try:
        yield
    finally:
        pythoncom.CoUninitialize()

def last_business_day(ref=None):
    d = (ref or datetime.now()) - timedelta(days=1)
    while d.weekday() >= 5 or d.strftime("%Y-%m-%d") in HOLIDAYS:  # 5=Sat,6=Sun
        d -= timedelta(days=1)
    return d

# === ORIGINAL (working) screenshot approach, with a private Excel instance ===
def export_range_png_one(excel_path, sheet_name, range_addr, out_name="excel_range.png"):
    """Copy range -> paste into temp chart -> export PNG. Closes only what it opened."""
    import time
    with com_apartment():
        excel = win32.DispatchEx("Excel.Application")   # private instance
        excel.Visible = False
        try:
            wb = excel.Workbooks.Open(excel_path)
            ws = wb.Worksheets(sheet_name) if sheet_name else wb.ActiveSheet
            rng = ws.Range(range_addr)

            # Copy as picture (screen, bitmap)
            rng.CopyPicture(Appearance=1, Format=2)  # 1=xlScreen, 2=xlBitmap

            # Temp chart sized to the range, then paste and export
            left, top, width, height = 0, 0, rng.Width, rng.Height
            chart_obj = ws.ChartObjects().Add(left, top, width, height)
            chart = chart_obj.Chart

            # Small pause so clipboard is ready
            pythoncom.PumpWaitingMessages()
            time.sleep(0.15)
            chart.Paste()

            out_path = Path(tempfile.gettempdir()) / out_name
            chart.Export(str(out_path), "PNG")

            # Clean up
            chart_obj.Delete()
            wb.Close(SaveChanges=False)
            return str(out_path)
        finally:
            excel.Quit()

def read_cell(excel_path, sheet_name, cell_addr):
    """Read a single cell value from a fresh, private Excel instance."""
    with com_apartment():
        excel = win32.DispatchEx("Excel.Application")
        excel.Visible = False
        try:
            wb = excel.Workbooks.Open(excel_path)
            ws = wb.Worksheets(sheet_name)
            val = ws.Range(cell_addr).Value
            wb.Close(SaveChanges=False)
            return val
        finally:
            excel.Quit()

def _sender_smtp(mail):
    try:
        if mail.SenderEmailType == "EX":
            exuser = mail.Sender.GetExchangeUser()
            if exuser:
                return exuser.PrimarySmtpAddress
        return mail.SenderEmailAddress
    except Exception:
        return None

def _restrict_contains(items, contains_text):
    esc = contains_text.replace("'", "''")
    dasl = f"@SQL=\"urn:schemas:httpmail:subject\" LIKE '%{esc}%'"
    try:
        return items.Restrict(dasl)
    except Exception:
        return [itm for itm in items if hasattr(itm, "Subject") and contains_text.lower() in (itm.Subject or "").lower()]

def find_sent_item_contains(subject_contains, sender_smtp=None, fallback_contains=None):
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    sent = ns.GetDefaultFolder(5)  # olFolderSentMail
    items = sent.Items
    items.Sort("[SentOn]", True)   # newest first

    for snippet in (subject_contains, fallback_contains):
        if not snippet:
            continue
        for itm in _restrict_contains(items, snippet):
            try:
                if itm.Class != 43:  # olMail
                    continue
                if sender_smtp:
                    smtp = _sender_smtp(itm)
                    if smtp and smtp.lower() != sender_smtp.lower():
                        continue
                return itm
            except Exception:
                continue
    raise RuntimeError(f"No Sent Items message found containing: '{subject_contains}'")

def reply_with_image_and_text(img_path, text_below, subject_contains, sender_smtp, fallback_contains=None):
    with com_apartment():
        outlook = win32.gencache.EnsureDispatch("Outlook.Application")
        original = find_sent_item_contains(subject_contains, sender_smtp, fallback_contains)
        reply = original.Reply()
        reply.Display()

        doc = reply.GetInspector.WordEditor  # Word document

        intro = "See screenshot and value below:\r\n"
        doc.Range(0, 0).InsertAfter(intro)

        r_img = doc.Range(0, len(intro))
        doc.InlineShapes.AddPicture(FileName=img_path, LinkToFile=False, SaveWithDocument=True, Range=r_img)

        after = doc.Range(r_img.End, r_img.End)
        after.InsertAfter("\r\n")
        doc.Range(after.End, after.End).InsertAfter(f"L3 (Yield): {text_below}\r\n")
        return reply

def main():
    # Subject snippet for the last business day (handles weekends; add holidays in HOLIDAYS to skip)
    last_bd = last_business_day()
    date_str = last_bd.strftime("%d/%m/%Y")
    base_phrase = "SGS Portfolios and B-S ("
    subject_contains = f"{base_phrase}{date_str})"
    fallback_contains = base_phrase

    # 1) Screenshot A1:E40 using the original working method
    png_path = export_range_png_one(EXCEL_PATH, SHEET_NAME, RANGE_ADDR, "excel_range.png")

    # 2) Read Yield!L3
    l3_val = read_cell(EXCEL_PATH, YIELD_SHEET, YIELD_CELL)

    # 3) Reply and paste image + L3 value
    reply_with_image_and_text(
        png_path,
        l3_val,
        subject_contains,
        TARGET_SENDER_SMTP,
        fallback_contains=fallback_contains
    )
    print("Reply draft opened with screenshot and L3 value. Review and press Send manually.")

if __name__ == "__main__":
    main()