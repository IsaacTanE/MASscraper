# -*- coding: utf-8 -*-
# Windows + Office desktop. Install: pip install pywin32

import tempfile
from pathlib import Path
from contextlib import contextmanager
import pythoncom
import win32com.client as win32
from datetime import datetime, timedelta

# ====== CONFIGURE THESE ======
EXCEL_PATH = r"C:\path\to\your\workbook.xlsx"   # <- change me
SHEET1_NAME = None                               # e.g. "Sheet1"; or None = ActiveSheet
RANGE1_ADDR = "A1:E40"

SHEET2_NAME = "Yield"
RANGE2_ADDR = "L1:Q27"

TARGET_SENDER_SMTP = "isaactane@dbs.com"         # since it's in Sent Items

# Optional: add company/SG holidays in 'YYYY-MM-DD' format
HOLIDAYS = {
    # "2025-08-09",  # example
}
# =============================

@contextmanager
def com_apartment():
    pythoncom.CoInitialize()
    try:
        yield
    finally:
        pythoncom.CoUninitialize()

def last_business_day(ref_dt=None, holidays=None):
    """Return the last business day (Mon-Fri and not in holidays)."""
    if ref_dt is None:
        ref_dt = datetime.now()
    d = ref_dt - timedelta(days=1)
    holidays = holidays or set()
    while d.weekday() >= 5 or d.strftime("%Y-%m-%d") in holidays:  # 5=Sat,6=Sun
        d -= timedelta(days=1)
    return d

def export_range_as_pngs(excel_path, shots):
    """
    Export multiple ranges to PNGs using a dedicated Excel instance; closes only what we opened.
    shots: list of tuples (sheet_name_or_None, range_addr, output_filename)
    Returns: list[str] of file paths
    """
    import time
    import traceback
    from pythoncom import com_error

    def log_step(msg):
        print(f"[excel-export] {msg}", flush=True)

    with com_apartment():
        excel = win32.DispatchEx("Excel.Application")  # isolated instance
        excel.Visible = False
        excel.ScreenUpdating = False
        excel.DisplayAlerts = False
        paths = []
        try:
            try:
                log_step(f"Opening workbook: {excel_path}")
                wb = excel.Workbooks.Open(excel_path)
            except com_error as e:
                log_step(f"ERROR opening workbook: {e}")
                raise

            for i, (sheet_name, range_addr, out_name) in enumerate(shots, 1):
                log_step(f"[shot {i}] Preparing {sheet_name or '(ActiveSheet)'}!{range_addr}")
                try:
                    ws = wb.Worksheets(sheet_name) if sheet_name else wb.ActiveSheet
                except com_error as e:
                    log_step(f"ERROR getting worksheet '{sheet_name}': {e}")
                    raise

                # Quick sanity: ensure the range exists
                try:
                    ws.Activate()
                    rng = ws.Range(range_addr)
                except com_error as e:
                    log_step(f"ERROR accessing range '{range_addr}': {e}")
                    raise

                # Ensure something is actually visible to capture
                if rng.Columns.Count == 0 or rng.Rows.Count == 0:
                    raise RuntimeError(f"Empty range: {range_addr}")
                if rng.Width == 0 or rng.Height == 0:
                    log_step(f"WARNING: range has zero width/height (hidden columns/rows?).")

                # Copy → Paste as SHAPE (robust path). Retry a few times for clipboard.
                shape = None
                for attempt in range(1, 6):
                    try:
                        log_step(f"[shot {i}] CopyPicture attempt {attempt}")
                        rng.CopyPicture(Appearance=1, Format=2)  # xlScreen=1, xlBitmap=2
                        pythoncom.PumpWaitingMessages()
                        time.sleep(0.20)

                        # Try modern paste: returns Shape directly in many builds
                        try:
                            shape = ws.Paste()
                        except Exception:
                            # Fallbacks if that failed
                            try:
                                shape = ws.Shapes.Paste()  # returns ShapeRange
                                # Convert ShapeRange -> Shape via first item
                                if hasattr(shape, "Item"):
                                    shape = shape.Item(1)
                            except Exception:
                                pic = ws.Pictures().Paste()
                                # Convert Picture -> Shape by grabbing last shape
                                shape = ws.Shapes(ws.Shapes.Count)

                        if not shape:
                            raise RuntimeError("Paste returned no shape")

                        # Size & position to match range (optional but neat)
                        shape.Left = rng.Left
                        shape.Top = rng.Top
                        shape.Width = rng.Width
                        shape.Height = rng.Height
                        break
                    except com_error as e:
                        log_step(f"[shot {i}] COM error during copy/paste: {e}")
                        time.sleep(0.3)
                        shape = None
                if not shape:
                    # Fallback: chart-based capture (very reliable)
                    log_step(f"[shot {i}] Falling back to chart export method")
                    try:
                        left, top, width, height = 0, 0, rng.Width, rng.Height
                        chart_obj = ws.ChartObjects().Add(left, top, width, height)
                        chart = chart_obj.Chart
                        rng.CopyPicture(Appearance=1, Format=2)
                        pythoncom.PumpWaitingMessages()
                        time.sleep(0.15)
                        chart.Paste()
                        out_path = Path(tempfile.gettempdir()) / out_name
                        chart.Export(str(out_path), "PNG")
                        chart_obj.Delete()
                        paths.append(str(out_path))
                        continue
                    except com_error as e:
                        log_step(f"[shot {i}] Fallback chart export FAILED: {e}")
                        raise

                # Primary path: export the Shape directly
                try:
                    out_path = Path(tempfile.gettempdir()) / out_name
                    log_step(f"[shot {i}] Exporting shape to {out_path}")
                    shape.Export(str(out_path))
                    # Rudimentary blank check (<1 KB often means empty)
                    try:
                        if out_path.exists() and out_path.stat().st_size < 1024:
                            log_step(f"[shot {i}] WARNING: tiny PNG ({out_path.stat().st_size} bytes)—may be blank.")
                    except Exception:
                        pass
                    paths.append(str(out_path))
                except com_error as e:
                    log_step(f"[shot {i}] Shape.Export COM error: {e}. Trying chart fallback…")
                    # Chart fallback if shape export borks for this build
                    try:
                        # Make sure we still have the bitmap on clipboard
                        rng.CopyPicture(Appearance=1, Format=2)
                        pythoncom.PumpWaitingMessages()
                        time.sleep(0.15)
                        chart_obj = ws.ChartObjects().Add(0, 0, rng.Width, rng.Height)
                        chart = chart_obj.Chart
                        chart.Paste()
                        out_path = Path(tempfile.gettempdir()) / out_name
                        chart.Export(str(out_path), "PNG")
                        chart_obj.Delete()
                        paths.append(str(out_path))
                    finally:
                        try:
                            shape.Delete()
                        except Exception:
                            pass
                else:
                    # Clean up the pasted shape
                    try:
                        shape.Delete()
                    except Exception:
                        pass

            try:
                wb.Close(SaveChanges=False)
            except com_error as e:
                log_step(f"WARNING closing workbook: {e}")

        finally:
            try:
                excel.ScreenUpdating = True
            except Exception:
                pass
            try:
                excel.Quit()
            except Exception:
                pass

        return paths


def _sender_smtp(mail):
    """Best-effort to get SMTP of the sender (handles Exchange)."""
    try:
        if mail.SenderEmailType == "EX":
            exuser = mail.Sender.GetExchangeUser()
            if exuser:
                return exuser.PrimarySmtpAddress
        return mail.SenderEmailAddress
    except Exception:
        return None

def _restrict_contains(items, contains_text):
    """
    Use DASL query for case-insensitive 'contains' on Subject.
    """
    # Escape embedded double-quotes for DASL
    esc = contains_text.replace('"', '""')
    dasl = f'@SQL="urn:schemas:httpmail:subject" LIKE \'%{esc}%\''
    try:
        return items.Restrict(dasl)
    except Exception:
        # Some profiles balk at @SQL—fallback to simple Items.Find/FindNext loop
        return [itm for itm in items if hasattr(itm, "Subject") and contains_text.lower() in (itm.Subject or "").lower()]

def find_sent_item_contains(subject_contains, sender_smtp=None, fallback_contains=None):
    """
    Find newest item in Sent Items where Subject contains subject_contains (DASL LIKE).
    If not found and fallback_contains provided, try the fallback.
    """
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    sent_folder = ns.GetDefaultFolder(5)  # olFolderSentMail

    items = sent_folder.Items
    items.Sort("[SentOn]", True)  # newest first

    # Primary attempt with dated snippet
    candidates = _restrict_contains(items, subject_contains)
    for itm in candidates:
        try:
            if itm.Class != 43:  # olMail
                continue
            if sender_smtp:
                smtp = _sender_smtp(itm)
                if smtp and smtp.lower() != sender_smtp.lower():
                    continue
            return itm
        except Exception:
            continue

    # Fallback attempt with base snippet (without date), if provided
    if fallback_contains:
        candidates = _restrict_contains(items, fallback_contains)
        for itm in candidates:
            try:
                if itm.Class != 43:
                    continue
                if sender_smtp:
                    smtp = _sender_smtp(itm)
                    if smtp and smtp.lower() != sender_smtp.lower():
                        continue
                return itm
            except Exception:
                continue

    raise RuntimeError(f"No matching message found in Sent Items for contains: '{subject_contains}'.")

def reply_with_two_images(subject_contains, sender_smtp, img1_path, img2_path, fallback_contains=None):
    """Open a Reply to the specific Sent Items message and paste img2 below img1."""
    with com_apartment():
        original = find_sent_item_contains(subject_contains, sender_smtp, fallback_contains)
        reply = original.Reply()
        reply.Display()

        inspector = reply.GetInspector
        doc = inspector.WordEditor

        intro = "See screenshots below:\r\n"
        doc.Range(0, 0).InsertAfter(intro)

        r1 = doc.Range(0, len(intro))
        doc.InlineShapes.AddPicture(
            FileName=img1_path, LinkToFile=False, SaveWithDocument=True, Range=r1
        )

        after_first = doc.Range(r1.End, r1.End)
        after_first.InsertAfter("\r\n")

        r2 = doc.Range(after_first.End, after_first.End)
        doc.InlineShapes.AddPicture(
            FileName=img2_path, LinkToFile=False, SaveWithDocument=True, Range=r2
        )

        doc.Range(r2.End, r2.End).InsertAfter("\r\n")
        return reply

def main():
    # Date snippet based on last business day (accounts for weekends + your optional holiday set)
    last_bd = last_business_day(datetime.now(), HOLIDAYS)
    date_str = last_bd.strftime("%d/%m/%Y")

    # Build the subject snippets
    # Use the inner phrase so contains is robust (works whether it's "RE:", "FW:", etc.)
    base_phrase = "SGS Portfolios and B-S ("
    subject_contains = f"{base_phrase}{date_str})"
    fallback_contains = base_phrase  # if date-specific search fails, match any with the base phrase

    # Export both screenshots
    img1_name = "excel_range_1.png"
    img2_name = "excel_range_2.png"
    paths = export_range_as_pngs(
        EXCEL_PATH,
        [
            (SHEET1_NAME, RANGE1_ADDR, img1_name),         # A1:E40
            (SHEET2_NAME, RANGE2_ADDR, img2_name),         # Yield!L1:Q27
        ],
    )
    img1_path, img2_path = paths

    print(f"Saved image 1 to: {img1_path}")
    print(f"Saved image 2 to: {img2_path}")
    print(f"Searching Sent Items for subject contains: '{subject_contains}' (fallback: '{fallback_contains}')")

    reply_with_two_images(subject_contains, TARGET_SENDER_SMTP, img1_path, img2_path, fallback_contains)
    print("Reply draft opened with both images pasted. Review and press Send manually.")

if __name__ == "__main__":
    main()