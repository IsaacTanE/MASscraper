# -*- coding: utf-8 -*-
# Requirements: pip install pywin32
# Windows + desktop Outlook/Excel

import tempfile
from pathlib import Path
from contextlib import contextmanager
from datetime import datetime, timedelta

import pythoncom
import win32com.client as win32

# ====== CONFIGURE ======
EXCEL_PATH = r"C:\path\to\your\workbook.xlsx"   # <- change me
SHEET_NAME = None                                # e.g. "Sheet1"; None = ActiveSheet
RANGE_ADDR = "A1:E40"

YIELD_SHEET = "Yield"
YIELD_CELL = "L3"

TARGET_SENDER_SMTP = "isaactane@dbs.com"         # since it's in Sent Items
HOLIDAYS = set()                                 # e.g. {"2025-01-01","2025-08-09"}
# =======================

@contextmanager
def com_apartment():
    pythoncom.CoInitialize()
    try:
        yield
    finally:
        pythoncom.CoUninitialize()

def last_business_day(ref=None):
    d = (ref or datetime.now()) - timedelta(days=1)
    while d.weekday() >= 5 or d.strftime("%Y-%m-%d") in HOLIDAYS:  # 5=Sat,6=Sun
        d -= timedelta(days=1)
    return d

# === ORIGINAL (working) screenshot approach, with a private Excel instance ===
def export_range_png_one(excel_path, sheet_name, range_addr, out_name="excel_range.png"):
    """
    Robust export:
      1) Open source wb, bring range on screen (visible/normal window, goto, zoom).
      2) Copy as picture (try metafile then bitmap).
      3) Open a NEW temporary workbook and paste there.
      4) Paste into a temp chart in the temp wb and export PNG.
      5) Close only what we opened; quit only our private Excel instance.
    """
    import time
    with com_apartment():
        xl = win32.DispatchEx("Excel.Application")   # private instance
        # Make visible so Windows actually paints the range
        xl.Visible = True
        xl.ScreenUpdating = True
        xl.DisplayAlerts = False
        try:
            src_wb = xl.Workbooks.Open(excel_path)
            ws = src_wb.Worksheets(sheet_name) if sheet_name else src_wb.ActiveSheet
            ws.Activate()

            # Make sure the window is normal & the range is actually on-screen
            try:
                xl.ActiveWindow.WindowState = -4143  # xlNormal
                xl.ActiveWindow.Zoom = 100
            except Exception:
                pass

            rng = ws.Range(range_addr)
            ws.Application.Goto(rng, Scroll=True)
            time.sleep(0.3)

            # Try copy as METAFILE first, then BITMAP as fallback
            copied = False
            for fmt in (-4147, 2):  # xlPicture, xlBitmap
                for _ in range(4):
                    try:
                        rng.CopyPicture(Appearance=1, Format=fmt)
                        pythoncom.PumpWaitingMessages()
                        time.sleep(0.3)
                        copied = True
                        break
                    except Exception:
                        time.sleep(0.25)
                if copied:
                    break
            if not copied:
                raise RuntimeError(f"Could not CopyPicture for {range_addr}")

            # Create a brand-new empty workbook to paste/export cleanly
            tmp_wb = xl.Workbooks.Add()
            tmp_ws = tmp_wb.Worksheets(1)
            tmp_ws.Activate()

            # Paste the picture into the temp sheet
            pic_shape = None
            for _ in range(6):
                try:
                    # In newer Excel, Paste returns a Shape; else we fetch the last shape
                    pasted = tmp_ws.Paste()
                    pic_shape = pasted if hasattr(pasted, "Name") else tmp_ws.Shapes(tmp_ws.Shapes.Count)
                    break
                except Exception:
                    time.sleep(0.25)
            if not pic_shape:
                # Fallback: try Pictures().Paste then fetch last shape
                try:
                    tmp_ws.Pictures().Paste()
                    pic_shape = tmp_ws.Shapes(tmp_ws.Shapes.Count)
                except Exception:
                    raise RuntimeError("Paste into temp workbook failed")

            # Create a temp chart in the temp workbook and export
            width = max(2, int(pic_shape.Width))
            height = max(2, int(pic_shape.Height))
            chobj = tmp_ws.ChartObjects().Add(0, 0, width, height)
            chart = chobj.Chart
            # Select the pasted picture and copy it, then paste onto the chart
            pic_shape.Copy()
            pythoncom.PumpWaitingMessages()
            time.sleep(0.2)
            chart.Paste()

            out_path = Path(tempfile.gettempdir()) / out_name
            chart.Export(str(out_path), "PNG")

            # Clean up temp objects
            try: chobj.Delete()
            except Exception: pass
            try: pic_shape.Delete()
            except Exception: pass

            # Close workbooks without saving
            tmp_wb.Close(SaveChanges=False)
            src_wb.Close(SaveChanges=False)

            # Sanity check file size
            if not out_path.exists() or out_path.stat().st_size < 1024:
                raise RuntimeError("Export produced a tiny/blank PNG; rendering likely failed.")

            return str(out_path)
        finally:
            # If you prefer to keep Excel hidden afterward, toggle Visible=False here before Quit()
            xl.Quit()

def find_inbox_item_contains_by_sender(subject_contains, sender_smtp, fallback_contains=None):
    """
    Find the newest email in Inbox where:
      - Subject contains `subject_contains` (DASL LIKE, case-insensitive)
      - Sender's SMTP address matches `sender_smtp`
    Falls back to `fallback_contains` if the date-specific snippet isn't found.
    """
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    inbox = ns.GetDefaultFolder(6)  # 6 = olFolderInbox

    items = inbox.Items
    items.Sort("[ReceivedTime]", True)  # newest first

    # Build a DASL query that matches Subject contains ... AND FromEmail equals ...
    def restrict_subject_and_sender(snippet):
        if not snippet:
            return None
        esc_subj = snippet.replace("'", "''")
        esc_from = sender_smtp.replace("'", "''")
        # urn:schemas:httpmail:fromemail is the SMTP address for most profiles
        dasl = (
            f'@SQL=("urn:schemas:httpmail:subject" LIKE \'%{esc_subj}%\') '
            f'AND ("urn:schemas:httpmail:fromemail" = \'{esc_from}\')'
        )
        try:
            return items.Restrict(dasl)
        except Exception:
            # Fallback: manual filter loop if DASL is blocked
            buf = []
            for itm in items:
                try:
                    if getattr(itm, "Class", None) != 43:  # olMail
                        continue
                    subj_ok = snippet.lower() in (itm.Subject or "").lower()
                    # Try to resolve SMTP address
                    smtp = None
                    try:
                        if itm.SenderEmailType == "EX":
                            exuser = itm.Sender.GetExchangeUser()
                            smtp = exuser.PrimarySmtpAddress if exuser else None
                        else:
                            smtp = itm.SenderEmailAddress
                    except Exception:
                        pass
                    from_ok = (smtp or "").lower() == sender_smtp.lower()
                    if subj_ok and from_ok:
                        buf.append(itm)
                except Exception:
                    continue
            return buf

    for snippet in (subject_contains, fallback_contains):
        candidates = restrict_subject_and_sender(snippet)
        if candidates:
            # Return the first (newest) candidate
            for itm in candidates:
                try:
                    if itm.Class == 43:
                        return itm
                except Exception:
                    continue

    raise RuntimeError(
        f"No Inbox email found from '{sender_smtp}' containing subject '{subject_contains}'."
    )


def read_cell(excel_path, sheet_name, cell_addr):
    """Read a single cell value from a fresh, private Excel instance."""
    with com_apartment():
        excel = win32.DispatchEx("Excel.Application")
        excel.Visible = False
        try:
            wb = excel.Workbooks.Open(excel_path)
            ws = wb.Worksheets(sheet_name)
            val = ws.Range(cell_addr).Value
            wb.Close(SaveChanges=False)
            return val
        finally:
            excel.Quit()

def _sender_smtp(mail):
    try:
        if mail.SenderEmailType == "EX":
            exuser = mail.Sender.GetExchangeUser()
            if exuser:
                return exuser.PrimarySmtpAddress
        return mail.SenderEmailAddress
    except Exception:
        return None

def _restrict_contains(items, contains_text):
    esc = contains_text.replace("'", "''")
    dasl = f"@SQL=\"urn:schemas:httpmail:subject\" LIKE '%{esc}%'"
    try:
        return items.Restrict(dasl)
    except Exception:
        return [itm for itm in items if hasattr(itm, "Subject") and contains_text.lower() in (itm.Subject or "").lower()]

def find_sent_item_contains(subject_contains, sender_smtp=None, fallback_contains=None):
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    sent = ns.GetDefaultFolder(5)  # olFolderSentMail
    items = sent.Items
    items.Sort("[SentOn]", True)   # newest first

    for snippet in (subject_contains, fallback_contains):
        if not snippet:
            continue
        for itm in _restrict_contains(items, snippet):
            try:
                if itm.Class != 43:  # olMail
                    continue
                if sender_smtp:
                    smtp = _sender_smtp(itm)
                    if smtp and smtp.lower() != sender_smtp.lower():
                        continue
                return itm
            except Exception:
                continue
    raise RuntimeError(f"No Sent Items message found containing: '{subject_contains}'")

def reply_with_image_and_text(img_path, text_below, subject_contains, sender_smtp, fallback_contains=None):
    with com_apartment():
        outlook = win32.gencache.EnsureDispatch("Outlook.Application")
        original = find_sent_item_contains(subject_contains, sender_smtp, fallback_contains)
        reply = original.Reply()
        reply.Display()

        doc = reply.GetInspector.WordEditor  # Word document

        intro = "See screenshot and value below:\r\n"
        doc.Range(0, 0).InsertAfter(intro)

        r_img = doc.Range(0, len(intro))
        doc.InlineShapes.AddPicture(FileName=img_path, LinkToFile=False, SaveWithDocument=True, Range=r_img)

        after = doc.Range(r_img.End, r_img.End)
        after.InsertAfter("\r\n")
        doc.Range(after.End, after.End).InsertAfter(f"L3 (Yield): {text_below}\r\n")
        return reply

def main():
    # Subject snippet for the last business day (handles weekends; add holidays in HOLIDAYS to skip)
    last_bd = last_business_day()
    date_str = last_bd.strftime("%d/%m/%Y")
    base_phrase = "SGS Portfolios and B-S ("
    subject_contains = f"{base_phrase}{date_str})"
    fallback_contains = base_phrase

    # 1) Screenshot A1:E40 using the original working method
    png_path = export_range_png_one(EXCEL_PATH, SHEET_NAME, RANGE_ADDR, "excel_range.png")

    # 2) Read Yield!L3
    l3_val = read_cell(EXCEL_PATH, YIELD_SHEET, YIELD_CELL)

    # 3) Reply and paste image + L3 value
    reply_with_image_and_text(
        png_path,
        l3_val,
        subject_contains,
        TARGET_SENDER_SMTP,
        fallback_contains=fallback_contains
    )
    print("Reply draft opened with screenshot and L3 value. Review and press Send manually.")

if __name__ == "__main__":
    main()