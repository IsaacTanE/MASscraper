# -*- coding: utf-8 -*-
# Windows + Office desktop. Install: pip install pywin32

import tempfile
from pathlib import Path
from contextlib import contextmanager
import pythoncom
import win32com.client as win32
from datetime import datetime, timedelta

# ====== CONFIGURE THESE ======
EXCEL_PATH = r"C:\path\to\your\workbook.xlsx"   # <- change me
SHEET1_NAME = None                               # e.g. "Sheet1"; or None = ActiveSheet
RANGE1_ADDR = "A1:E40"

SHEET2_NAME = "Yield"
RANGE2_ADDR = "L1:Q27"

TARGET_SENDER_SMTP = "isaactane@dbs.com"         # since it's in Sent Items

# Optional: add company/SG holidays in 'YYYY-MM-DD' format
HOLIDAYS = {
    # "2025-08-09",  # example
}
# =============================

@contextmanager
def com_apartment():
    pythoncom.CoInitialize()
    try:
        yield
    finally:
        pythoncom.CoUninitialize()

def last_business_day(ref_dt=None, holidays=None):
    """Return the last business day (Mon-Fri and not in holidays)."""
    if ref_dt is None:
        ref_dt = datetime.now()
    d = ref_dt - timedelta(days=1)
    holidays = holidays or set()
    while d.weekday() >= 5 or d.strftime("%Y-%m-%d") in holidays:  # 5=Sat,6=Sun
        d -= timedelta(days=1)
    return d

def export_range_as_pngs(excel_path, shots):
    """
    Export multiple ranges to PNGs using a dedicated Excel instance; closes only what we opened.
    shots: list of tuples (sheet_name_or_None, range_addr, output_filename)
    Returns: list[str] of file paths
    """
    import time
    with com_apartment():
        excel = win32.DispatchEx("Excel.Application")  # isolated instance
        excel.Visible = False
        excel.ScreenUpdating = False
        paths = []
        try:
            wb = excel.Workbooks.Open(excel_path)
            for sheet_name, range_addr, out_name in shots:
                ws = wb.Worksheets(sheet_name) if sheet_name else wb.ActiveSheet

                ws.Activate()
                rng = ws.Range(range_addr)
                rng.Select()

                # Retry loop for clipboard reliability
                ok = False
                for _ in range(5):
                    try:
                        rng.CopyPicture(Appearance=1, Format=2)  # xlScreen=1, xlBitmap=2
                        pythoncom.PumpWaitingMessages()
                        time.sleep(0.15)
                        pic = ws.Paste()  # Paste returns a Shape in modern Excel
                        ok = True
                        break
                    except Exception:
                        time.sleep(0.2)

                if not ok:
                    raise RuntimeError(f"Failed to capture range {range_addr} as picture.")

                # Get the pasted shape — Paste() returns the shape object directly in newer versions
                if hasattr(pic, "Name"):
                    shape = ws.Shapes(pic.Name)
                else:
                    # Fallback: assume it's the last shape on the sheet
                    shape = ws.Shapes(ws.Shapes.Count)

                # Position/size neatly over the range
                shape.Left = rng.Left
                shape.Top = rng.Top
                shape.Width = rng.Width
                shape.Height = rng.Height

                # Export shape directly
                out_path = Path(tempfile.gettempdir()) / out_name
                shape.Export(str(out_path))  # Export is available on Shapes

                # Delete pasted shape from sheet
                shape.Delete()

                paths.append(str(out_path))

            wb.Close(SaveChanges=False)
        finally:
            try:
                excel.ScreenUpdating = True
            except Exception:
                pass
            excel.Quit()
        return paths
def _sender_smtp(mail):
    """Best-effort to get SMTP of the sender (handles Exchange)."""
    try:
        if mail.SenderEmailType == "EX":
            exuser = mail.Sender.GetExchangeUser()
            if exuser:
                return exuser.PrimarySmtpAddress
        return mail.SenderEmailAddress
    except Exception:
        return None

def _restrict_contains(items, contains_text):
    """
    Use DASL query for case-insensitive 'contains' on Subject.
    """
    # Escape embedded double-quotes for DASL
    esc = contains_text.replace('"', '""')
    dasl = f'@SQL="urn:schemas:httpmail:subject" LIKE \'%{esc}%\''
    try:
        return items.Restrict(dasl)
    except Exception:
        # Some profiles balk at @SQL—fallback to simple Items.Find/FindNext loop
        return [itm for itm in items if hasattr(itm, "Subject") and contains_text.lower() in (itm.Subject or "").lower()]

def find_sent_item_contains(subject_contains, sender_smtp=None, fallback_contains=None):
    """
    Find newest item in Sent Items where Subject contains subject_contains (DASL LIKE).
    If not found and fallback_contains provided, try the fallback.
    """
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    sent_folder = ns.GetDefaultFolder(5)  # olFolderSentMail

    items = sent_folder.Items
    items.Sort("[SentOn]", True)  # newest first

    # Primary attempt with dated snippet
    candidates = _restrict_contains(items, subject_contains)
    for itm in candidates:
        try:
            if itm.Class != 43:  # olMail
                continue
            if sender_smtp:
                smtp = _sender_smtp(itm)
                if smtp and smtp.lower() != sender_smtp.lower():
                    continue
            return itm
        except Exception:
            continue

    # Fallback attempt with base snippet (without date), if provided
    if fallback_contains:
        candidates = _restrict_contains(items, fallback_contains)
        for itm in candidates:
            try:
                if itm.Class != 43:
                    continue
                if sender_smtp:
                    smtp = _sender_smtp(itm)
                    if smtp and smtp.lower() != sender_smtp.lower():
                        continue
                return itm
            except Exception:
                continue

    raise RuntimeError(f"No matching message found in Sent Items for contains: '{subject_contains}'.")

def reply_with_two_images(subject_contains, sender_smtp, img1_path, img2_path, fallback_contains=None):
    """Open a Reply to the specific Sent Items message and paste img2 below img1."""
    with com_apartment():
        original = find_sent_item_contains(subject_contains, sender_smtp, fallback_contains)
        reply = original.Reply()
        reply.Display()

        inspector = reply.GetInspector
        doc = inspector.WordEditor

        intro = "See screenshots below:\r\n"
        doc.Range(0, 0).InsertAfter(intro)

        r1 = doc.Range(0, len(intro))
        doc.InlineShapes.AddPicture(
            FileName=img1_path, LinkToFile=False, SaveWithDocument=True, Range=r1
        )

        after_first = doc.Range(r1.End, r1.End)
        after_first.InsertAfter("\r\n")

        r2 = doc.Range(after_first.End, after_first.End)
        doc.InlineShapes.AddPicture(
            FileName=img2_path, LinkToFile=False, SaveWithDocument=True, Range=r2
        )

        doc.Range(r2.End, r2.End).InsertAfter("\r\n")
        return reply

def main():
    # Date snippet based on last business day (accounts for weekends + your optional holiday set)
    last_bd = last_business_day(datetime.now(), HOLIDAYS)
    date_str = last_bd.strftime("%d/%m/%Y")

    # Build the subject snippets
    # Use the inner phrase so contains is robust (works whether it's "RE:", "FW:", etc.)
    base_phrase = "SGS Portfolios and B-S ("
    subject_contains = f"{base_phrase}{date_str})"
    fallback_contains = base_phrase  # if date-specific search fails, match any with the base phrase

    # Export both screenshots
    img1_name = "excel_range_1.png"
    img2_name = "excel_range_2.png"
    paths = export_range_as_pngs(
        EXCEL_PATH,
        [
            (SHEET1_NAME, RANGE1_ADDR, img1_name),         # A1:E40
            (SHEET2_NAME, RANGE2_ADDR, img2_name),         # Yield!L1:Q27
        ],
    )
    img1_path, img2_path = paths

    print(f"Saved image 1 to: {img1_path}")
    print(f"Saved image 2 to: {img2_path}")
    print(f"Searching Sent Items for subject contains: '{subject_contains}' (fallback: '{fallback_contains}')")

    reply_with_two_images(subject_contains, TARGET_SENDER_SMTP, img1_path, img2_path, fallback_contains)
    print("Reply draft opened with both images pasted. Review and press Send manually.")

if __name__ == "__main__":
    main()