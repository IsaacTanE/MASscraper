# -*- coding: utf-8 -*-
# Requirements: pip install pywin32
# Windows + desktop Outlook/Excel

import tempfile
from pathlib import Path
from contextlib import contextmanager
from datetime import datetime, timedelta

import pythoncom
import win32com.client as win32

# ====== CONFIGURE ======
EXCEL_PATH = r"C:\path\to\your\workbook.xlsx"   # <- change me
SHEET_NAME = None                                # e.g. "Sheet1"; None = ActiveSheet
RANGE_ADDR = "A1:E40"

YIELD_SHEET = "Yield"
YIELD_CELL = "L3"

TARGET_SENDER_SMTP = "isaactane@dbs.com"         # since it's in Sent Items
HOLIDAYS = set()                                 # e.g. {"2025-01-01","2025-08-09"}
# =======================

@contextmanager
def com_apartment():
    pythoncom.CoInitialize()
    try:
        yield
    finally:
        pythoncom.CoUninitialize()

def last_business_day(ref=None):
    d = (ref or datetime.now()) - timedelta(days=1)
    while d.weekday() >= 5 or d.strftime("%Y-%m-%d") in HOLIDAYS:  # 5=Sat,6=Sun
        d -= timedelta(days=1)
    return d

# === ORIGINAL (working) screenshot approach, with a private Excel instance ===
def export_range_png_one(excel_path, sheet_name, range_addr, out_name="excel_range.png"):
    """
    Robust export:
      1) Open source wb, bring range on screen (visible/normal window, goto, zoom).
      2) Copy as picture (try metafile then bitmap).
      3) Open a NEW temporary workbook and paste there.
      4) Paste into a temp chart in the temp wb and export PNG.
      5) Close only what we opened; quit only our private Excel instance.
    """
    import time
    with com_apartment():
        xl = win32.DispatchEx("Excel.Application")   # private instance
        # Make visible so Windows actually paints the range
        xl.Visible = True
        xl.ScreenUpdating = True
        xl.DisplayAlerts = False
        try:
            src_wb = xl.Workbooks.Open(excel_path)
            ws = src_wb.Worksheets(sheet_name) if sheet_name else src_wb.ActiveSheet
            ws.Activate()

            # Make sure the window is normal & the range is actually on-screen
            try:
                xl.ActiveWindow.WindowState = -4143  # xlNormal
                xl.ActiveWindow.Zoom = 100
            except Exception:
                pass

            rng = ws.Range(range_addr)
            ws.Application.Goto(rng, Scroll=True)
            time.sleep(0.3)

            # Try copy as METAFILE first, then BITMAP as fallback
            copied = False
            for fmt in (-4147, 2):  # xlPicture, xlBitmap
                for _ in range(4):
                    try:
                        rng.CopyPicture(Appearance=1, Format=fmt)
                        pythoncom.PumpWaitingMessages()
                        time.sleep(0.3)
                        copied = True
                        break
                    except Exception:
                        time.sleep(0.25)
                if copied:
                    break
            if not copied:
                raise RuntimeError(f"Could not CopyPicture for {range_addr}")

            # Create a brand-new empty workbook to paste/export cleanly
            tmp_wb = xl.Workbooks.Add()
            tmp_ws = tmp_wb.Worksheets(1)
            tmp_ws.Activate()

            # Paste the picture into the temp sheet
            pic_shape = None
            for _ in range(6):
                try:
                    # In newer Excel, Paste returns a Shape; else we fetch the last shape
                    pasted = tmp_ws.Paste()
                    pic_shape = pasted if hasattr(pasted, "Name") else tmp_ws.Shapes(tmp_ws.Shapes.Count)
                    break
                except Exception:
                    time.sleep(0.25)
            if not pic_shape:
                # Fallback: try Pictures().Paste then fetch last shape
                try:
                    tmp_ws.Pictures().Paste()
                    pic_shape = tmp_ws.Shapes(tmp_ws.Shapes.Count)
                except Exception:
                    raise RuntimeError("Paste into temp workbook failed")

            # Create a temp chart in the temp workbook and export
            width = max(2, int(pic_shape.Width))
            height = max(2, int(pic_shape.Height))
            chobj = tmp_ws.ChartObjects().Add(0, 0, width, height)
            chart = chobj.Chart
            # Select the pasted picture and copy it, then paste onto the chart
            pic_shape.Copy()
            pythoncom.PumpWaitingMessages()
            time.sleep(0.2)
            chart.Paste()

            out_path = Path(tempfile.gettempdir()) / out_name
            chart.Export(str(out_path), "PNG")

            # Clean up temp objects
            try: chobj.Delete()
            except Exception: pass
            try: pic_shape.Delete()
            except Exception: pass

            # Close workbooks without saving
            tmp_wb.Close(SaveChanges=False)
            src_wb.Close(SaveChanges=False)

            # Sanity check file size
            if not out_path.exists() or out_path.stat().st_size < 1024:
                raise RuntimeError("Export produced a tiny/blank PNG; rendering likely failed.")

            return str(out_path)
        finally:
            # If you prefer to keep Excel hidden afterward, toggle Visible=False here before Quit()
            xl.Quit()

def find_inbox_item_contains_by_sender(subject_contains, sender_smtp, fallback_contains=None):
    """
    Find the newest email in Inbox where:
      - Subject contains `subject_contains` (DASL LIKE, case-insensitive)
      - Sender's SMTP address matches `sender_smtp`
    Falls back to `fallback_contains` if the date-specific snippet isn't found.
    """
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    inbox = ns.GetDefaultFolder(6)  # 6 = olFolderInbox

    items = inbox.Items
    items.Sort("[ReceivedTime]", True)  # newest first

    # Build a DASL query that matches Subject contains ... AND FromEmail equals ...
    def restrict_subject_and_sender(snippet):
        if not snippet:
            return None
        esc_subj = snippet.replace("'", "''")
        esc_from = sender_smtp.replace("'", "''")
        # urn:schemas:httpmail:fromemail is the SMTP address for most profiles
        dasl = (
            f'@SQL=("urn:schemas:httpmail:subject" LIKE \'%{esc_subj}%\') '
            f'AND ("urn:schemas:httpmail:fromemail" = \'{esc_from}\')'
        )
        try:
            return items.Restrict(dasl)
        except Exception:
            # Fallback: manual filter loop if DASL is blocked
            buf = []
            for itm in items:
                try:
                    if getattr(itm, "Class", None) != 43:  # olMail
                        continue
                    subj_ok = snippet.lower() in (itm.Subject or "").lower()
                    # Try to resolve SMTP address
                    smtp = None
                    try:
                        if itm.SenderEmailType == "EX":
                            exuser = itm.Sender.GetExchangeUser()
                            smtp = exuser.PrimarySmtpAddress if exuser else None
                        else:
                            smtp = itm.SenderEmailAddress
                    except Exception:
                        pass
                    from_ok = (smtp or "").lower() == sender_smtp.lower()
                    if subj_ok and from_ok:
                        buf.append(itm)
                except Exception:
                    continue
            return buf

    for snippet in (subject_contains, fallback_contains):
        candidates = restrict_subject_and_sender(snippet)
        if candidates:
            # Return the first (newest) candidate
            for itm in candidates:
                try:
                    if itm.Class == 43:
                        return itm
                except Exception:
                    continue

    raise RuntimeError(
        f"No Inbox email found from '{sender_smtp}' containing subject '{subject_contains}'."
    )


def read_cell(excel_path, sheet_name, cell_addr):
    """Read a single cell value from a fresh, private Excel instance."""
    with com_apartment():
        excel = win32.DispatchEx("Excel.Application")
        excel.Visible = False
        try:
            wb = excel.Workbooks.Open(excel_path)
            ws = wb.Worksheets(sheet_name)
            val = ws.Range(cell_addr).Value
            wb.Close(SaveChanges=False)
            return val
        finally:
            excel.Quit()

def _sender_smtp(mail):
    try:
        if mail.SenderEmailType == "EX":
            exuser = mail.Sender.GetExchangeUser()
            if exuser:
                return exuser.PrimarySmtpAddress
        return mail.SenderEmailAddress
    except Exception:
        return None

def _restrict_contains(items, contains_text):
    esc = contains_text.replace("'", "''")
    dasl = f"@SQL=\"urn:schemas:httpmail:subject\" LIKE '%{esc}%'"
    try:
        return items.Restrict(dasl)
    except Exception:
        return [itm for itm in items if hasattr(itm, "Subject") and contains_text.lower() in (itm.Subject or "").lower()]

def find_sent_item_contains(subject_contains, sender_smtp=None, fallback_contains=None):
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    sent = ns.GetDefaultFolder(5)  # olFolderSentMail
    items = sent.Items
    items.Sort("[SentOn]", True)   # newest first

    for snippet in (subject_contains, fallback_contains):
        if not snippet:
            continue
        for itm in _restrict_contains(items, snippet):
            try:
                if itm.Class != 43:  # olMail
                    continue
                if sender_smtp:
                    smtp = _sender_smtp(itm)
                    if smtp and smtp.lower() != sender_smtp.lower():
                        continue
                return itm
            except Exception:
                continue
    raise RuntimeError(f"No Sent Items message found containing: '{subject_contains}'")

def reply_with_image_and_text(img_path, text_below, subject_contains, sender_smtp, fallback_contains=None):
    with com_apartment():
        outlook = win32.gencache.EnsureDispatch("Outlook.Application")
        original = find_sent_item_contains(subject_contains, sender_smtp, fallback_contains)
        reply = original.Reply()
        reply.Display()

        doc = reply.GetInspector.WordEditor  # Word document

        intro = "See screenshot and value below:\r\n"
        doc.Range(0, 0).InsertAfter(intro)

        r_img = doc.Range(0, len(intro))
        doc.InlineShapes.AddPicture(FileName=img_path, LinkToFile=False, SaveWithDocument=True, Range=r_img)

        after = doc.Range(r_img.End, r_img.End)
        after.InsertAfter("\r\n")
        doc.Range(after.End, after.End).InsertAfter(f"L3 (Yield): {text_below}\r\n")
        return reply

def main():
    # Subject snippet for the last business day (handles weekends; add holidays in HOLIDAYS to skip)
    last_bd = last_business_day()
    date_str = last_bd.strftime("%d/%m/%Y")
    base_phrase = "SGS Portfolios and B-S ("
    subject_contains = f"{base_phrase}{date_str})"
    fallback_contains = base_phrase

    # 1) Screenshot A1:E40 using the original working method
    png_path = export_range_png_one(EXCEL_PATH, SHEET_NAME, RANGE_ADDR, "excel_range.png")

    # 2) Read Yield!L3
    l3_val = read_cell(EXCEL_PATH, YIELD_SHEET, YIELD_CELL)

    # 3) Reply and paste image + L3 value
    reply_with_image_and_text(
        png_path,
        l3_val,
        subject_contains,
        TARGET_SENDER_SMTP,
        fallback_contains=fallback_contains
    )
    print("Reply draft opened with screenshot and L3 value. Review and press Send manually.")

if __name__ == "__main__":
    main()



new function

import time

# MAPI property tags
PR_SENDER_EMAIL_ADDRESS = "http://schemas.microsoft.com/mapi/proptag/0x0065001E"

def _smtp_from_mail(item):
    """Resolve sender SMTP robustly for a MailItem."""
    try:
        if item.SenderEmailType == "EX":
            exu = item.Sender.GetExchangeUser()
            if exu and exu.PrimarySmtpAddress:
                return exu.PrimarySmtpAddress
        return item.SenderEmailAddress
    except Exception:
        # Last-resort try via PropertyAccessor (may still be X.500 on some profiles)
        try:
            return item.PropertyAccessor.GetProperty(PR_SENDER_EMAIL_ADDRESS)
        except Exception:
            return None

def _build_dasl_filter(subject_snippet, sender_smtp):
    """
    Build a DASL filter that matches:
      (Subject LIKE '%snippet%' OR ConversationTopic LIKE '%snippet%')
      AND (fromemail == sender OR PR_SENDER_EMAIL_ADDRESS == sender)
    Case-insensitive LIKE is okay in DASL.
    """
    esc_subj = subject_snippet.replace("'", "''")
    esc_sender = sender_smtp.replace("'", "''")
    return (
        f'@SQL=('
        f'  "urn:schemas:httpmail:subject" LIKE \'%{esc_subj}%\' '
        f'  OR "urn:schemas:httpmail:conversationtopic" LIKE \'%{esc_subj}%\''
        f') AND ('
        f'  "urn:schemas:httpmail:fromemail" = \'{esc_sender}\' '
        f'  OR "{PR_SENDER_EMAIL_ADDRESS}" = \'{esc_sender}\''
        f')'
    )

def _advanced_search_inbox(outlook, dasl_filter, tag="__search__", timeout_sec=6.0):
    """
    Run AdvancedSearch over Inbox (including subfolders). Wait up to timeout_sec for results.
    Returns a Results collection (possibly empty).
    """
    ns = outlook.GetNamespace("MAPI")
    inbox = ns.GetDefaultFolder(6)  # olFolderInbox
    scope = inbox.FolderPath  # e.g. "\\Mailbox - You\\Inbox"
    # AdvancedSearch(scope, Filter, SearchSubFolders, Tag)
    srch = outlook.AdvancedSearch(scope, dasl_filter, True, tag)
    # Wait briefly for query to execute (poll results)
    deadline = time.time() + timeout_sec
    while time.time() < deadline:
        try:
            res = srch.Results
            # AdvancedSearch returns a Results collection that updates; we can break early if it has items
            if res and res.Count is not None:
                return res
        except Exception:
            pass
        time.sleep(0.15)
    return srch.Results  # return whatever we have

def find_inbox_item_contains_by_sender(subject_contains, sender_smtp, fallback_contains=None, max_take=1):
    """
    Find the newest Inbox (or subfolder) message FROM sender_smtp whose Subject/ConversationTopic contains snippet.
    Tries the dated snippet first, then the fallback snippet.
    Returns a MailItem; raises RuntimeError if not found.
    """
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")

    # Try dated snippet first
    for snippet in [subject_contains, fallback_contains]:
        if not snippet:
            continue

        # 1) Fast path: AdvancedSearch with wide DASL (subject OR conversationtopic, 2 sender props)
        dasl = _build_dasl_filter(snippet, sender_smtp)
        results = _advanced_search_inbox(outlook, dasl_filter=dasl, timeout_sec=6.0)
        # Results are not guaranteed sorted; pick the newest by ReceivedTime
        candidates = []
        try:
            for i in range(1, results.Count + 1):
                itm = results.Item(i)
                if getattr(itm, "Class", None) != 43:  # olMail only
                    continue
                candidates.append(itm)
        except Exception:
            candidates = []

        if candidates:
            # Sort by ReceivedTime desc
            try:
                candidates.sort(key=lambda m: getattr(m, "ReceivedTime", None), reverse=True)
            except Exception:
                pass
            # Return first
            return candidates[0]

        # 2) Fallback: manual scan over Inbox + subfolders (top ~400 items total)
        ns = outlook.GetNamespace("MAPI")
        inbox = ns.GetDefaultFolder(6)
        to_visit = [inbox]
        try:
            to_visit.extend(list(inbox.Folders))
        except Exception:
            pass

        examined = 0
        newest = None
        newest_time = None

        for folder in to_visit:
            try:
                items = folder.Items
                items.Sort("[ReceivedTime]", True)
            except Exception:
                continue
            # Scan only the most recent slice for speed
            count = min(getattr(items, "Count", 0), 400)
            for i in range(1, count + 1):
                itm = items.Item(i)
                try:
                    if getattr(itm, "Class", None) != 43:
                        continue
                    subj = (itm.Subject or "")
                    convo = getattr(itm, "ConversationTopic", "") or ""
                    text = (subj + " " + convo).lower()
                    if snippet.lower() not in text:
                        continue
                    smtp = (_smtp_from_mail(itm) or "").lower()
                    if smtp != sender_smtp.lower():
                        continue
                    rt = getattr(itm, "ReceivedTime", None)
                    if newest_time is None or (rt and rt > newest_time):
                        newest, newest_time = itm, rt
                    examined += 1
                    if max_take and newest:
                        # We already sort newest-first per folder; short-circuit
                        return newest
                except Exception:
                    continue

        # If we get here, no hit for this snippet; loop to try the fallback snippet
        continue

    # Nothing matched after both snippets
    raise RuntimeError(
        f"No Inbox email found from '{sender_smtp}' containing '{subject_contains}'"
        + (f" (also tried '{fallback_contains}')" if fallback_contains else "")
    )


def find_inbox_simple(subject_contains, sender_smtp, fallback_contains=None):
    """
    Find the newest email in the TOP-LEVEL Inbox (no subfolders) where:
      - Subject contains snippet (case-insensitive), and
      - SenderEmailAddress == sender_smtp (SMTP form, not EX/X.500)
    Tries the dated snippet first, then fallback snippet.
    """
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    inbox = ns.GetDefaultFolder(6)  # olFolderInbox
    items = inbox.Items
    items.Sort("[ReceivedTime]", True)  # newest first

    def restrict_subject_sender(snippet):
        if not snippet:
            return []
        # Try DASL restrict first (fast); fall back to manual loop if blocked
        esc_subj = snippet.replace("'", "''")
        esc_from = sender_smtp.replace("'", "''")
        dasl = (
            f'@SQL=("urn:schemas:httpmail:subject" LIKE \'%{esc_subj}%\') '
            f'AND ("urn:schemas:httpmail:fromemail" = \'{esc_from}\')'
        )
        try:
            return [itm for itm in items.Restrict(dasl) if getattr(itm, "Class", None) == 43]
        except Exception:
            buf = []
            count = min(getattr(items, "Count", 0), 300)  # scan recent slice
            for i in range(1, count + 1):
                itm = items.Item(i)
                if getattr(itm, "Class", None) != 43:
                    continue
                subj_ok = snippet.lower() in ((itm.Subject or "").lower())
                from_ok = ((itm.SenderEmailAddress or "").lower() == sender_smtp.lower())
                if subj_ok and from_ok:
                    buf.append(itm)
            return buf

    for snippet in (subject_contains, fallback_contains):
        for itm in restrict_subject_sender(snippet):
            return itm

    raise RuntimeError(
        f"No Inbox email found from '{sender_smtp}' containing '{subject_contains}'"
        + (f" (also tried '{fallback_contains}')" if fallback_contains else "")
    )