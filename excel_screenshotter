# -*- coding: utf-8 -*-
import tempfile
from pathlib import Path
from contextlib import contextmanager
from datetime import datetime, timedelta

import pythoncom
import win32com.client as win32

# ====== CONFIGURE ======
EXCEL_PATH = r"C:\path\to\your\workbook.xlsx"   # <- change me
SHEET_NAME = None                                # None = ActiveSheet
RANGE_ADDR = "A1:E40"

YIELD_SHEET = "Yield"
YIELD_CELL = "L3"

TARGET_SENDER_SMTP = "isaactane@dbs.com"         # it's in Sent Items
HOLIDAYS = set()                                 # optional: {"2025-01-01", ...}
# =======================

@contextmanager
def com_apartment():
    pythoncom.CoInitialize()
    try:
        yield
    finally:
        pythoncom.CoUninitialize()

def last_business_day(ref=None):
    d = (ref or datetime.now()) - timedelta(days=1)
    while d.weekday() >= 5 or d.strftime("%Y-%m-%d") in HOLIDAYS:  # 5=Sat,6=Sun
        d -= timedelta(days=1)
    return d

def export_range_png_one(excel_path, sheet_name, range_addr, out_name="excel_range.png"):
    """
    Robust export that avoids blank images:
      - make Excel visible and foreground (just during capture)
      - copy as metafile (xlPicture) instead of bitmap
      - paste into a temp chart and export
    """
    import time
    with com_apartment():
        xl = win32.DispatchEx("Excel.Application")
        # MAKE IT VISIBLE so Windows actually renders the range
        xl.Visible = True
        xl.ScreenUpdating = True
        xl.DisplayAlerts = False
        try:
            wb = xl.Workbooks.Open(excel_path)
            ws = wb.Worksheets(sheet_name) if sheet_name else wb.ActiveSheet
            ws.Activate()

            # Make sure the window can render (not minimized/offscreen)
            try:
                xl.ActiveWindow.WindowState = -4143  # xlNormal
            except Exception:
                pass
            try:
                xl.ActiveWindow.Zoom = 100
            except Exception:
                pass

            rng = ws.Range(range_addr)
            # Scroll the range into view so CopyPicture has real pixels to grab
            ws.Application.Goto(rng, Scroll=True)
            time.sleep(0.3)

            # Create a temp chart sized to the range
            width, height = max(2, int(rng.Width)), max(2, int(rng.Height))
            chobj = ws.ChartObjects().Add(0, 0, width, height)
            chart = chobj.Chart

            out_path = Path(tempfile.gettempdir()) / out_name
            ok = False
            # Use xlPicture (-4147) metafile; more reliable than xlBitmap(2)
            for _ in range(6):
                rng.CopyPicture(Appearance=1, Format=-4147)  # xlScreen=1, xlPicture=-4147
                pythoncom.PumpWaitingMessages()
                time.sleep(0.35)  # give clipboard time
                chart.Paste()
                chart.Export(str(out_path), "PNG")
                if out_path.exists() and out_path.stat().st_size > 1024:
                    ok = True
                    break
                time.sleep(0.35)

            chobj.Delete()
            if not ok:
                raise RuntimeError(f"Failed to export visible image for {range_addr}")
            return str(out_path)
        finally:
            try:
                wb.Close(SaveChanges=False)
            except Exception:
                pass
            # you can set xl.Visible=False here if you don't want to see Excel linger
            xl.Quit()

def read_cell(excel_path, sheet_name, cell_addr):
    """Read a single cell value (no side effects)."""
    with com_apartment():
        xl = win32.DispatchEx("Excel.Application")
        xl.Visible = False
        try:
            wb = xl.Workbooks.Open(excel_path)
            ws = wb.Worksheets(sheet_name)
            val = ws.Range(cell_addr).Value
            wb.Close(SaveChanges=False)
            return val
        finally:
            xl.Quit()

def _sender_smtp(mail):
    try:
        if mail.SenderEmailType == "EX":
            exuser = mail.Sender.GetExchangeUser()
            if exuser:
                return exuser.PrimarySmtpAddress
        return mail.SenderEmailAddress
    except Exception:
        return None

def _restrict_contains(items, contains_text):
    esc = contains_text.replace("'", "''")
    dasl = f"@SQL=\"urn:schemas:httpmail:subject\" LIKE '%{esc}%'"
    try:
        return items.Restrict(dasl)
    except Exception:
        # Fallback loop if DASL not allowed
        return [itm for itm in items if hasattr(itm, "Subject") and contains_text.lower() in (itm.Subject or "").lower()]

def find_sent_item_contains(subject_contains, sender_smtp=None, fallback_contains=None):
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    sent = ns.GetDefaultFolder(5)  # olFolderSentMail
    items = sent.Items
    items.Sort("[SentOn]", True)  # newest first

    for snippet in (subject_contains, fallback_contains):
        if not snippet:
            continue
        for itm in _restrict_contains(items, snippet):
            try:
                if itm.Class != 43:  # olMail
                    continue
                if sender_smtp:
                    smtp = _sender_smtp(itm)
                    if smtp and smtp.lower() != sender_smtp.lower():
                        continue
                return itm
            except Exception:
                continue
    raise RuntimeError(f"No Sent Items message found containing: '{subject_contains}'")

def reply_with_image_and_text(img_path, text_below, subject_contains, sender_smtp, fallback_contains=None):
    with com_apartment():
        original = find_sent_item_contains(subject_contains, sender_smtp, fallback_contains)
        reply = original.Reply()
        reply.Display()

        doc = reply.GetInspector.WordEditor  # Word document
        intro = "See screenshot and value below:\r\n"
        doc.Range(0, 0).InsertAfter(intro)

        r_img = doc.Range(0, len(intro))
        doc.InlineShapes.AddPicture(FileName=img_path, LinkToFile=False, SaveWithDocument=True, Range=r_img)

        # newline + value below
        after = doc.Range(r_img.End, r_img.End)
        after.InsertAfter("\r\n")
        doc.Range(after.End, after.End).InsertAfter(f"L3 (Yield): {text_below}\r\n")
        return reply

def main():
    # Build subject snippet for last business day
    last_bd = last_business_day()
    date_str = last_bd.strftime("%d/%m/%Y")
    base_phrase = "SGS Portfolios and B-S ("
    subject_contains = f"{base_phrase}{date_str})"
    fallback_contains = base_phrase  # if date-specific fails

    # 1) Screenshot A1:E40
    png_path = export_range_png_one(EXCEL_PATH, SHEET_NAME, RANGE_ADDR, "excel_range_1.png")

    # 2) Read Yield!L3
    l3_val = read_cell(EXCEL_PATH, YIELD_SHEET, YIELD_CELL)

    # 3) Reply and paste image + value
    reply_with_image_and_text(
        png_path,
        l3_val,
        subject_contains,
        TARGET_SENDER_SMTP,
        fallback_contains=fallback_contains
    )
    print("Reply draft opened with screenshot and L3 value. Review and press Send manually.")

if __name__ == "__main__":
    main()